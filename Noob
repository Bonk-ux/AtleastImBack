-- ==============================================
-- ATV FUNCTIONALITY (UPDATED: FAKE PLASTICS GROUND COLLISION + SMOOTH FOLLOW + DEATH RESET + NOCLIP + CHARACTER ANCHOR)
-- ==============================================
if not LPH_OBFUSCATED then
    LPH_JIT_MAX = function(...) return ... end
end

-- Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local Workspace = workspace
local Lighting = cloneref(game:GetService("Lighting"))

-- Character
local character = Workspace.Const.Ignore.LocalCharacter
local top = character.Top
local middle = character.Middle
local bottom = character.Bottom
local prism = top.Prism1

-- Store the original position of the neck part
local originalPrismCFrame = prism.CFrame

-- Variables
local longNeckEnabled = false
local collisionToggle = false
local ClosestATV = nil
local speed = 55
local travel = Vector3.zero
local Enabled = true -- Auto-enabled
local atvbypass = true
local anchorToggle = false -- Starts as false (ATV anchor state)
local characterAnchorToggle = false -- Independent character anchor state
local characterSeatOffset = nil -- Track character's relative position to seat
local smoothFactor = 0.1 -- Smoothness set to 0.1 (more gradual)

local MIN_SPEED = 1
local MAX_SPEED = 150
local previousSpeed = speed
local isSpeedToggled = false

-- ATV Look Restriction Bypass
local trident = { gc = { camera = nil } }
LPH_JIT_MAX(function()
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" and type(rawget(v, "SetMaxRelativeLookExtentsY")) == "function" then
            trident.gc.camera = v
        end
    end
end)()

task.spawn(function()
    while task.wait() do
        if trident.gc.camera then
            trident.gc.camera.SetMaxRelativeLookExtentsY(10000)
        end
    end
end)

-- Reset anchor state on character death
local function onCharacterDeath()
    anchorToggle = false
    characterAnchorToggle = false
    -- Unanchor all character parts
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = false
        end
    end
    -- Unanchor ATV parts if needed
    if ClosestATV then
        for _, part in ipairs(ClosestATV:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
            end
        end
    end
    characterSeatOffset = nil
end

-- Listen for character death (assuming humanoid exists)
local humanoid = character:FindFirstChildOfClass("Humanoid")
if humanoid then
    humanoid.Died:Connect(onCharacterDeath)
else
    -- Wait for humanoid if not found initially
    character.ChildAdded:Connect(function(child)
        if child:IsA("Humanoid") then
            child.Died:Connect(onCharacterDeath)
        end
    end)
end

-- ATV Collision Toggle / Noclip (F Key) - Only affects ATV now
local function toggleATVCollision()
    if not ClosestATV then return end
    collisionToggle = not collisionToggle
    -- Toggle ONLY ATV collision
    for _, part in ipairs(ClosestATV:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("MeshPart") or part:IsA("Seat") or part:IsA("Part") then
            part.CanCollide = collisionToggle
        end
    end
end

-- Toggle ATV Anchoring (Z Key)
local function toggleATVAnchoring()
    anchorToggle = not anchorToggle -- Switches ATV anchor state
    -- Anchor/unanchor ATV parts
    if ClosestATV then
        for _, part in ipairs(ClosestATV:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = anchorToggle
            end
        end
    end
    -- Save initial character-seat offset when ATV is anchored
    if anchorToggle and ClosestATV then
        local atvSeat = ClosestATV:FindFirstChild("Seat")
        if atvSeat then
            characterSeatOffset = middle.Position - atvSeat.Position -- Preserve relative position
        end
    else
        -- Clear offset when ATV is unanchored to stop following
        characterSeatOffset = nil
    end
end

-- Toggle Character Anchoring (K Key)
local function toggleCharacterAnchoring()
    characterAnchorToggle = not characterAnchorToggle -- Switches character anchor state
    -- Anchor/unanchor character parts
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = characterAnchorToggle
        end
    end
end

local function clampSpeed(value, min, max)
    return math.max(min, math.min(max, value))
end

local function adjustSpeed(amount)
    speed = clampSpeed(speed + amount, MIN_SPEED, MAX_SPEED)
end

local function toggleSpeed()
    if isSpeedToggled then
        speed = previousSpeed
    else
        previousSpeed = speed
        speed = 28
    end
    isSpeedToggled = not isSpeedToggled
end

-- Toggle Long Neck (L Key)
local function toggleLongNeck()
    longNeckEnabled = not longNeckEnabled
    top.Prism1.CFrame = longNeckEnabled and originalPrismCFrame - Vector3.yAxis * 7 or originalPrismCFrame
end

-- Fixed ATV Detection (Plastics2, Seat direct in model)
local function GetClosestATV()
    local closestATV, closestDistance = nil, math.huge

    -- Iterate over top-level models in Workspace
    for _, model in ipairs(Workspace:GetChildren()) do
        if model:IsA("Model") then
            -- Check for Plastics2 and Seat directly in the model
            local plastics2 = model:FindFirstChild("Plastics2")
            local seat = model:FindFirstChild("Seat")

            if plastics2 and seat then
                local distance = (plastics2.Position - middle.Position).Magnitude
                if distance < closestDistance then
                    closestATV = model -- Set top-level model as ClosestATV
                    closestDistance = distance
                end
            end
        end
    end

    return closestATV
end

-- FAKE PLASTICS GROUND COLLISION: Fire TouchInterest to trick game into thinking Plastics are on ground (prevents teleport)
local function fakePlasticsGroundCollision()
    if not ClosestATV then return end
    local plastics = ClosestATV:FindFirstChild("Plastics2") or ClosestATV:FindFirstChild("Plastics")
    if not plastics then return end

    -- Find ground part (simplified: use Workspace ground or first terrain part)
    local ground = Workspace:FindFirstChild("Ground") or Workspace.Terrain

    if ground and ground:IsA("BasePart") then
        for _, part in ipairs(plastics:GetDescendants()) do
            if part:IsA("BasePart") then
                -- Fire TouchInterest to simulate contact (0 = start touch, 1 = end touch)
                part:FireTouchInterest(ground, 0)
                task.delay(0.1, function()
                    part:FireTouchInterest(ground, 1)
                end)
            end
        end
    end
end

local function FlyHack()
    RunService.RenderStepped:Connect(function()
        ClosestATV = GetClosestATV()
        local atvSeat = ClosestATV and ClosestATV:FindFirstChild("Seat")

        if Enabled and ClosestATV then
            local plastics = ClosestATV.Plastics2
            local atvModel = ClosestATV
            plastics.Velocity = Vector3.zero

            -- FAKE PLASTICS GROUND COLLISION: Run every frame to prevent teleport
            fakePlasticsGroundCollision()

            local flip2 = ClosestATV.Body:FindFirstChild("Flip2")
            if not flip2 then
                local newFlip = ClosestATV.Body.Flip:Clone()
                newFlip.Name = "Flip2"
                newFlip.Enabled = true
                newFlip.Parent = ClosestATV.Body
            else
                flip2.Enabled = true
            end

            if travel.Magnitude > 0 then
                local delta = travel.Unit * speed * RunService.RenderStepped:Wait()
                for _, part in ipairs(atvModel:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Anchored = anchorToggle -- ATV anchor state
                        if anchorToggle then
                            part.Position += delta -- Move via position when anchored
                        else
                            part.Velocity = travel.Unit * speed -- Use velocity when unanchored
                        end
                    end
                end
                -- Smoothly follow seat position ONLY when BOTH ATV AND CHARACTER are anchored
                if anchorToggle and characterAnchorToggle and atvSeat and characterSeatOffset then
                    local targetMiddlePos = atvSeat.Position + characterSeatOffset
                    local deltaToSeat = (targetMiddlePos - middle.Position) * smoothFactor
                    -- Apply smooth delta to all character parts (respect character anchor state)
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.Position += deltaToSeat
                        end
                    end
                end
            else
                for _, part in ipairs(atvModel:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Velocity = Vector3.zero
                        part.Anchored = anchorToggle -- ATV anchor state
                    end
                end
                -- Smoothly stay locked to seat ONLY when BOTH ATV AND CHARACTER are anchored
                if anchorToggle and characterAnchorToggle and atvSeat and characterSeatOffset then
                    local targetMiddlePos = atvSeat.Position + characterSeatOffset
                    local deltaToSeat = (targetMiddlePos - middle.Position) * smoothFactor
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.Position += deltaToSeat
                        end
                    end
                end
            end
        else
            local flip2 = ClosestATV and ClosestATV.Body:FindFirstChild("Flip2")
            if flip2 then
                flip2.Enabled = false
            end
        end
    end)
end

-- Fixed Flip Bypass (targets Flip in Body folder, flip_att removed)
RunService.RenderStepped:Connect(function()
    for _, v in ipairs(Workspace:GetChildren()) do
        local body = v:FindFirstChild("Body", true) -- Search for nested Body folder
        if body then
            local flip = body:FindFirstChild("Flip")
            if flip and atvbypass then
                flip.Enabled = true
                flip.RigidityEnabled = true
                flip.Responsiveness = math.huge
            end
        end
    end
end)

-- Keybinds (Updated: Z = ATV Anchor, K = Character Anchor)
UserInputService.InputBegan:Connect(function(input, isProcessed)
    if isProcessed then return end

    if input.KeyCode == Enum.KeyCode.L then
        toggleLongNeck()
    elseif input.KeyCode == Enum.KeyCode.F then
        toggleATVCollision()
    elseif input.KeyCode == Enum.KeyCode.Q then
        toggleSpeed()
    elseif input.KeyCode == Enum.KeyCode.V then
        adjustSpeed(5)
    elseif input.KeyCode == Enum.KeyCode.N then
        adjustSpeed(-5)
    elseif input.KeyCode == Enum.KeyCode.Z then -- Z toggles ATV anchor state
        toggleATVAnchoring()
    elseif input.KeyCode == Enum.KeyCode.K then -- K toggles character anchor state
        toggleCharacterAnchoring()
    end
end)

-- Movement for ATV Fly
RunService.RenderStepped:Connect(function()
    if Enabled and ClosestATV then
        local cameraCFrame = Camera.CFrame
        travel = Vector3.zero

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then travel += cameraCFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then travel -= cameraCFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then travel += cameraCFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then travel -= cameraCFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.X) then travel += cameraCFrame.UpVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then travel -= cameraCFrame.UpVector end
    else
        travel = Vector3.zero
    end
end)

FlyHack()

-- ==============================================
-- ADDITIONAL FUNCTIONS (BELOW ATV CODE)
-- ==============================================

-- External Trident Survival Script
loadstring(game:HttpGet("https://raw.githubusercontent.com/Efial/Chi/434704f21c527353a18f6e885e47b8117759de7d/Scripts/TridentSurvival.lua", true))()

-- Services for Additional Features
local VirtualInputManager = game:GetService("VirtualInputManager")
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

-- Big Head Effect (Auto-Active)
local VirtualInputManager = game:GetService("VirtualInputManager")
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

-- Big Head Effect (Auto-Active + NO-COLLIDE)
local HeadSizeEnabled = true
local headScale = Vector3.new(9, 9, 9)
local headTransparency = 0.5
local v4 = 0
local v5 = 25
local v6 = {}

local function applyHeadChanges(v7)
    local l_Head_0 = v7:FindFirstChild("Head")
    if l_Head_0 and l_Head_0:IsA("BasePart") then
        if HeadSizeEnabled then
            if not v6[l_Head_0] then
                v6[l_Head_0] = {
                    Size = l_Head_0.Size,
                    Transparency = l_Head_0.Transparency,
                    CanCollide = l_Head_0.CanCollide -- Save original collision state
                }
            end
            l_Head_0.Size = headScale
            l_Head_0.Transparency = headTransparency
            l_Head_0.CanCollide = false -- Make big head non-colliding
        elseif v6[l_Head_0] then
            l_Head_0.Size = v6[l_Head_0].Size
            l_Head_0.Transparency = v6[l_Head_0].Transparency
            l_Head_0.CanCollide = v6[l_Head_0].CanCollide -- Restore original collision
            v6[l_Head_0] = nil
        end
    end
end

-- Big Head Update Loop
RunService.RenderStepped:Connect(function()
    v4 = v4 + 1
    if v5 <= v4 then
        v4 = 0
        for _, v11 in pairs(workspace:GetChildren()) do
            if v11:IsA("Model") and v11 ~= localPlayer.Character then
                applyHeadChanges(v11)
            end
        end
    end
end)

-- CJ Button (FULLY FIXED)
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CJButtonGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local CJButton = Instance.new("TextButton")
CJButton.Name = "CJButton"
CJButton.Parent = screenGui
CJButton.Text = "CJ"
CJButton.Font = Enum.Font.SourceSansBold
CJButton.TextSize = 28
CJButton.TextColor3 = Color3.fromRGB(200, 200, 200)
CJButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
CJButton.BackgroundTransparency = 0.4
CJButton.Size = UDim2.new(0, 70, 0, 70)
CJButton.Position = UDim2.new(0.850000024, 29, 0.800000012, -75)
CJButton.AnchorPoint = Vector2.new(0.5, 0.5)
CJButton.BorderSizePixel = 0
CJButton.AutoButtonColor = false

local UICorner1 = Instance.new("UICorner")
UICorner1.CornerRadius = UDim.new(1, 0)
UICorner1.Parent = CJButton

local UIStroke1 = Instance.new("UIStroke")
UIStroke1.Thickness = 2
UIStroke1.Color = Color3.fromRGB(40, 40, 40)
UIStroke1.Transparency = 0.2
UIStroke1.Parent = CJButton

local function glowEffect(active)
	CJButton.BackgroundTransparency = active and 0.2 or 0.4
end

local function pressCJ()
	VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.C, false, game)
	VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
end

local function releaseCJ()
	VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.C, false, game)
	VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
end

CJButton.MouseButton1Down:Connect(function()
	pressCJ()
	glowEffect(true)
end)

CJButton.MouseButton1Up:Connect(function()
	releaseCJ()
	glowEffect(false)
end)

CJButton.TouchLongPress:Connect(function()
	pressCJ()
	glowEffect(true)
end)

-- Fixed touch release
CJButton.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.Touch then
		releaseCJ()
		glowEffect(false)
	end
end)

-- L Button
local LButton = Instance.new("ImageButton")
LButton.Name = "LButton"
LButton.Parent = playerGui
LButton.Size = UDim2.new(0, 85, 0, 85)
LButton.Position = UDim2.new(0.85, -654, 0.8, -220)
LButton.BackgroundTransparency = 1
LButton.Image = "rbxassetid://3926305904"
LButton.ImageRectOffset = Vector2.new(4, 4)
LButton.ImageRectSize = Vector2.new(36, 36)
LButton.ImageColor3 = Color3.fromRGB(180, 0, 255)

LButton.MouseButton1Click:Connect(function()
	VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.L, false, game)
	task.wait(0.05)
	VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.L, false, game)
end)

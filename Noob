-- ==============================================
-- VEHICLE FLY FUNCTIONALITY (ATV + CAR SUPPORT)
-- ==============================================
if not LPH_OBFUSCATED then
    LPH_JIT_MAX = function(...) return ... end
end

-- Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local Workspace = workspace
local Lighting = cloneref(game:GetService("Lighting"))
local localPlayer = Players.LocalPlayer

-- Character
local character = Workspace.Const.Ignore.LocalCharacter
local top = character.Top
local middle = character.Middle
local bottom = character.Bottom
local prism = top.Prism1

-- Store original neck position
local originalPrismCFrame = prism.CFrame

-- Variables
local longNeckEnabled = false
local collisionToggle = false
local ClosestVehicle = nil
local speed = 55
local travel = Vector3.zero
local Enabled = true
local atvbypass = true
local anchorToggle = false
local characterAnchorToggle = false
local characterSeatOffset = nil
local smoothFactor = 0.1
local currentVelocity = Vector3.zero
local decelerationFactor = 0.95
local MIN_SPEED = 1
local MAX_SPEED = 150
local previousSpeed = speed
local isSpeedToggled = false

-- Vehicle Look Restriction Bypass
local trident = { gc = { camera = nil } }
LPH_JIT_MAX(function()
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" and type(rawget(v, "SetMaxRelativeLookExtentsY")) == "function" then
            trident.gc.camera = v
        end
    end
end)()

task.spawn(function()
    while task.wait() do
        if trident.gc.camera then
            trident.gc.camera.SetMaxRelativeLookExtentsY(10000)
        end
    end
end)

-- Core Reset Function
local function fullReset()
    anchorToggle = false
    characterAnchorToggle = false
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = false
        end
    end
    if ClosestVehicle then
        for _, part in ipairs(ClosestVehicle:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
            end
        end
        local flip2 = ClosestVehicle.Body and ClosestVehicle.Body:FindFirstChild("Flip2")
        if flip2 then
            flip2.Enabled = false
        end
    end
    longNeckEnabled = false
    prism.CFrame = originalPrismCFrame
    characterSeatOffset = nil
    currentVelocity = Vector3.zero
end

-- Death Handler
local function onCharacterDeath()
    fullReset()
end

-- Spawn Handler
local function onCharacterSpawn(newCharacter)
    character = newCharacter or Workspace.Const.Ignore.LocalCharacter
    top = character:WaitForChild("Top")
    middle = character:WaitForChild("Middle")
    bottom = character:WaitForChild("Bottom")
    prism = top:WaitForChild("Prism1")
    originalPrismCFrame = prism.CFrame
    fullReset()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Died:Connect(onCharacterDeath)
    else
        character.ChildAdded:Connect(function(child)
            if child:IsA("Humanoid") then
                child.Died:Connect(onCharacterDeath)
            end
        end)
    end
end

-- Connect events
localPlayer.CharacterAdded:Connect(onCharacterSpawn)
local humanoid = character:FindFirstChildOfClass("Humanoid")
if humanoid then
    humanoid.Died:Connect(onCharacterDeath)
else
    character.ChildAdded:Connect(function(child)
        if child:IsA("Humanoid") then
            child.Died:Connect(onCharacterDeath)
        end
    end)
end

-- Vehicle Detection (ATV + CAR) - FIXED WITH RECURSIVE SEARCH
local function GetClosestVehicle()
    local closest, closestDistance = nil, math.huge
    for _, model in ipairs(Workspace:GetChildren()) do
        if model:IsA("Model") then
            -- Search for seat recursively (handles nested seats in Body for Cars)
            local seat = model:FindFirstChild("Seat", true)
            -- Look for main part
            local mainPart = model:FindFirstChild("Body") or model:FindFirstChild("Plastics2")
            if seat and mainPart then
                local distance = (mainPart.Position - middle.Position).Magnitude
                if distance < closestDistance and distance < 45 then
                    closest = model
                    closestDistance = distance
                end
            end
        end
    end
    return closest
end

-- Toggle Vehicle Collision (F Key)
local function toggleVehicleCollision()
    if not ClosestVehicle then return end
    collisionToggle = not collisionToggle
    for _, part in ipairs(ClosestVehicle:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("MeshPart") or part:IsA("Seat") then
            part.CanCollide = collisionToggle
        end
    end
end

-- Toggle Vehicle Anchoring (Z Key) - FIXED WITH RECURSIVE SEARCH
local function toggleVehicleAnchoring()
    anchorToggle = not anchorToggle
    if ClosestVehicle then
        for _, part in ipairs(ClosestVehicle:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = anchorToggle
            end
        end
        -- Search for seat recursively (handles nested seats in Body for Cars)
        local vehicleSeat = ClosestVehicle:FindFirstChild("Seat", true)
        if anchorToggle and vehicleSeat then
            characterSeatOffset = middle.Position - vehicleSeat.Position
            currentVelocity = Vector3.zero
        else
            characterSeatOffset = nil
        end
    end
end

-- Toggle Character Anchoring (K Key)
local function toggleCharacterAnchoring()
    characterAnchorToggle = not characterAnchorToggle
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Anchored = characterAnchorToggle
        end
    end
end

-- Speed Functions
local function clampSpeed(value, min, max)
    return math.max(min, math.min(max, value))
end

local function adjustSpeed(amount)
    speed = clampSpeed(speed + amount, MIN_SPEED, MAX_SPEED)
end

local function toggleSpeed()
    if isSpeedToggled then
        speed = previousSpeed
    else
        previousSpeed = speed
        speed = 28
    end
    isSpeedToggled = not isSpeedToggled
end

-- Toggle Long Neck (L Key)
local function toggleLongNeck()
    longNeckEnabled = not longNeckEnabled
    prism.CFrame = longNeckEnabled and originalPrismCFrame - Vector3.yAxis * 7 or originalPrismCFrame
end

-- Fly Hack Logic
local function FlyHack()
    -- Movement/RenderStepped
    local renderConnection
    renderConnection = RunService.RenderStepped:Connect(function()
        ClosestVehicle = GetClosestVehicle()
        -- Search for seat recursively (handles nested seats in Body for Cars)
        local vehicleSeat = ClosestVehicle and ClosestVehicle:FindFirstChild("Seat", true)
        local mainPart = ClosestVehicle and (ClosestVehicle:FindFirstChild("Body") or ClosestVehicle:FindFirstChild("Plastics2"))
        local deltaTime = RunService.RenderStepped:Wait()
        
        if Enabled and ClosestVehicle and mainPart then
            -- Zero main part velocity
            mainPart.Velocity = Vector3.zero
            
            -- Flip2 handling
            local bodyPart = ClosestVehicle:FindFirstChild("Body")
            local flip2 = bodyPart and bodyPart:FindFirstChild("Flip2") or mainPart:FindFirstChild("Flip2")
            if not flip2 then
                local sourceFlip = bodyPart and bodyPart:FindFirstChild("Flip") or mainPart:FindFirstChild("Flip")
                if sourceFlip then
                    local newFlip = sourceFlip:Clone()
                    newFlip.Name = "Flip2"
                    newFlip.Enabled = true
                    newFlip.Parent = bodyPart or mainPart
                end
            else
                flip2.Enabled = true
            end
            
            if travel.Magnitude > 0 then
                currentVelocity = travel.Unit * speed
                local vehicleModel = ClosestVehicle
                if anchorToggle then
                    local delta = currentVelocity * deltaTime
                    for _, part in ipairs(vehicleModel:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.Anchored = true
                            part.Position += delta
                        end
                    end
                else
                    for _, part in ipairs(vehicleModel:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.Anchored = false
                            part.Velocity = currentVelocity
                        end
                    end
                end
            end
            
            -- Smooth character follow
            if anchorToggle and characterAnchorToggle and vehicleSeat and characterSeatOffset then
                local targetMiddlePos = vehicleSeat.Position + characterSeatOffset
                local deltaToSeat = (targetMiddlePos - middle.Position) * smoothFactor
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Position += deltaToSeat
                    end
                end
            end
        else
            currentVelocity = Vector3.zero
            if ClosestVehicle then
                local bodyPart = ClosestVehicle:FindFirstChild("Body")
                local flip2 = bodyPart and bodyPart:FindFirstChild("Flip2")
                if flip2 then
                    flip2.Enabled = false
                end
            end
        end
    end)
    
    -- Deceleration (Heartbeat)
    local heartbeatConnection
    heartbeatConnection = RunService.Heartbeat:Connect(function()
        if not Enabled or not ClosestVehicle then return end
        
        local isMoving = UserInputService:IsKeyDown(Enum.KeyCode.W) or UserInputService:IsKeyDown(Enum.KeyCode.S) or
                         UserInputService:IsKeyDown(Enum.KeyCode.A) or UserInputService:IsKeyDown(Enum.KeyCode.D) or
                         UserInputService:IsKeyDown(Enum.KeyCode.X) or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
        
        if travel.Magnitude == 0 and not isMoving then
            local vehicleModel = ClosestVehicle
            if not anchorToggle then
                currentVelocity *= decelerationFactor
                if currentVelocity.Magnitude < 0.1 then
                    currentVelocity = Vector3.zero
                end
                for _, part in ipairs(vehicleModel:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Anchored = false
                        part.Velocity = currentVelocity
                    end
                end
            else
                currentVelocity = Vector3.zero
                for _, part in ipairs(vehicleModel:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Anchored = true
                        part.Velocity = Vector3.zero
                    end
                end
            end
        end
    end)
end

-- Flip Bypass
RunService.RenderStepped:Connect(function()
    for _, v in ipairs(Workspace:GetChildren()) do
        local body = v:FindFirstChild("Body", true)
        if body then
            local flip = body:FindFirstChild("Flip")
            if flip and atvbypass then
                flip.Enabled = true
                flip.RigidityEnabled = true
                flip.Responsiveness = math.huge
            end
        end
    end
end)

-- Keybinds
UserInputService.InputBegan:Connect(function(input, isProcessed)
    if isProcessed then return end
    if input.KeyCode == Enum.KeyCode.L then
        toggleLongNeck()
    elseif input.KeyCode == Enum.KeyCode.F then
        toggleVehicleCollision()
    elseif input.KeyCode == Enum.KeyCode.Q then
        toggleSpeed()
    elseif input.KeyCode == Enum.KeyCode.V then
        adjustSpeed(5)
    elseif input.KeyCode == Enum.KeyCode.N then
        adjustSpeed(-5)
    elseif input.KeyCode == Enum.KeyCode.Z then
        toggleVehicleAnchoring()
    elseif input.KeyCode == Enum.KeyCode.K then
        toggleCharacterAnchoring()
    end
end)

-- Movement Input
RunService.RenderStepped:Connect(function()
    if Enabled and ClosestVehicle then
        local cameraCFrame = Camera.CFrame
        travel = Vector3.zero
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then travel += cameraCFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then travel -= cameraCFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then travel += cameraCFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then travel -= cameraCFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.X) then travel += cameraCFrame.UpVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then travel -= cameraCFrame.UpVector end
        if travel.Magnitude > 0 then
            travel = travel.Unit
        end
    else
        travel = Vector3.zero
    end
end)

FlyHack()

-- ==============================================
-- ADDITIONAL FUNCTIONS (UNCHANGED)
-- ==============================================
loadstring(game:HttpGet("https://raw.githubusercontent.com/Efial/Chi/434704f21c527353a18f6e885e47b8117759de7d/Scripts/TridentSurvival.lua", true))()

-- CJ Button GUI
local VirtualInputManager = game:GetService("VirtualInputManager")
local playerGui = localPlayer:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CJButtonGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local CJButton = Instance.new("TextButton")
CJButton.Name = "CJButton"
CJButton.Parent = screenGui
CJButton.Text = "CJ"
CJButton.Font = Enum.Font.SourceSansBold
CJButton.TextSize = 28
CJButton.TextColor3 = Color3.fromRGB(200, 200, 200)
CJButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
CJButton.BackgroundTransparency = 0.4
CJButton.Size = UDim2.new(0, 70, 0, 70)
CJButton.Position = UDim2.new(0.850000024, 29, 0.800000012, -75)
CJButton.AnchorPoint = Vector2.new(0.5, 0.5)
CJButton.BorderSizePixel = 0
CJButton.AutoButtonColor = false

local UICorner1 = Instance.new("UICorner")
UICorner1.CornerRadius = UDim.new(1, 0)
UICorner1.Parent = CJButton

local UIStroke1 = Instance.new("UIStroke")
UIStroke1.Thickness = 2
UIStroke1.Color = Color3.fromRGB(40, 40, 40)
UIStroke1.Transparency = 0.2
UIStroke1.Parent = CJButton

local function glowEffect(active)
    CJButton.BackgroundTransparency = active and 0.2 or 0.4
end

local function pressCJ()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.C, false, game)
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
end

local function releaseCJ()
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.C, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
end

CJButton.MouseButton1Down:Connect(function()
    pressCJ()
    glowEffect(true)
end)

CJButton.MouseButton1Up:Connect(function()
    releaseCJ()
    glowEffect(false)
end)

CJButton.TouchLongPress:Connect(function()
    pressCJ()
    glowEffect(true)
end)

CJButton.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        releaseCJ()
        glowEffect(false)
    end
end)

-- L Button
local LButton = Instance.new("ImageButton")
LButton.Name = "LButton"
LButton.Parent = playerGui
LButton.Size = UDim2.new(0, 85, 0, 85)
LButton.Position = UDim2.new(0.85, -654, 0.8, -220)
LButton.BackgroundTransparency = 1
LButton.Image = "rbxassetid://3926305904"
LButton.ImageRectOffset = Vector2.new(4, 4)
LButton.ImageRectSize = Vector2.new(36, 36)
LButton.ImageColor3 = Color3.fromRGB(180, 0, 255)
LButton.MouseButton1Click:Connect(function()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.L, false, game)
    task.wait(0.05)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.L, false, game)
end)

-- Drill No Cooldown (U Toggle)
local features = { drillNoCooldown = false }

local function toggleDrillNoCooldown()
    features.drillNoCooldown = not features.drillNoCooldown
    for _, v in getgc(true) do
        if type(v) == "table" and rawget(v, "type") == "MiningDrill" then
            v.AttackCooldown = features.drillNoCooldown and 0.001 or 0.15
        end
    end
    print("Drill No Cooldown:", features.drillNoCooldown and "Enabled (MAX SPEED)" or "Disabled")
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.U then
        toggleDrillNoCooldown()
    end
end)

-- WASD Control Panel
local wasdGui = Instance.new("ScreenGui")
wasdGui.Name = "WASDControlPanel"
wasdGui.ResetOnSpawn = false
wasdGui.DisplayOrder = 1
wasdGui.Parent = playerGui

local buttonFrameLeft = Instance.new("Frame")
buttonFrameLeft.Name = "WASDFrameLeft"
buttonFrameLeft.Size = UDim2.new(0, 120, 0, 100)
buttonFrameLeft.Position = UDim2.new(0.08, 0, 0.02, 0)
buttonFrameLeft.BackgroundTransparency = 1
buttonFrameLeft.Parent = wasdGui

local buttonFrameRight = Instance.new("Frame")
buttonFrameRight.Name = "WASDFrameRight"
buttonFrameRight.Size = UDim2.new(0, 80, 0, 100)
buttonFrameRight.Position = UDim2.new(0.82, 0, -0.02, 0)
buttonFrameRight.BackgroundTransparency = 1
buttonFrameRight.Parent = wasdGui

local function createWASDButton(name, text, position, parentFrame)
    local button = Instance.new("TextButton")
    button.Name = name .. "Button"
    button.Text = text
    button.Font = Enum.Font.SourceSansBold
    button.TextSize = 24
    button.TextColor3 = Color3.new(1, 1, 1)
    button.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
    button.BackgroundTransparency = 0.3
    button.Size = UDim2.new(0, 40, 0, 50)
    button.Position = position
    button.AnchorPoint = Vector2.new(0, 0)
    button.BorderSizePixel = 0
    button.AutoButtonColor = false
    button.ZIndex = 2
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.2, 0)
    corner.Parent = button
    
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.new(0.1, 0.1, 0.1)
    stroke.Parent = button

    local keyCode = Enum.KeyCode[name]
    local isPressed = false
    
    local function pressKey()
        if not isPressed then
            isPressed = true
            VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
            button.BackgroundTransparency = 0.1
        end
    end
    
    local function releaseKey()
        if isPressed then
            isPressed = false
            VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
            button.BackgroundTransparency = 0.3
        end
    end

    button.MouseButton1Down:Connect(pressKey)
    button.MouseButton1Up:Connect(releaseKey)
    button.MouseLeave:Connect(releaseKey)
    button.TouchLongPress:Connect(pressKey)
    button.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            releaseKey()
        end
    end)
    button.Parent = parentFrame
    return button
end

-- Create buttons
createWASDButton("L", "L", UDim2.new(0, 0, 0, 0), buttonFrameLeft)
createWASDButton("W", "W", UDim2.new(0, 40, 0, 0), buttonFrameLeft)
createWASDButton("F", "F", UDim2.new(0, 80, 0, 0), buttonFrameLeft)
createWASDButton("A", "A", UDim2.new(0, 0, 0, 50), buttonFrameLeft)
createWASDButton("S", "S", UDim2.new(0, 40, 0, 50), buttonFrameLeft)
createWASDButton("D", "D", UDim2.new(0, 80, 0, 50), buttonFrameLeft)

createWASDButton("U", "U", UDim2.new(0, 0, 0, 0), buttonFrameRight)
createWASDButton("Q", "Q", UDim2.new(0, 40, 0, 0), buttonFrameRight)
createWASDButton("Z", "Z", UDim2.new(0, 0, 0, 50), buttonFrameRight)
createWASDButton("K", "K", UDim2.new(0, 40, 0, 50), buttonFrameRight)

-- ==============================================
-- ADDITIONAL FUNCTIONS (CrossHair)
-- ==============================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- CREATE GUI
local CrosshairGui = Instance.new("ScreenGui")
CrosshairGui.Name = "WorkingImageCrosshair"
CrosshairGui.IgnoreGuiInset = true -- Critical for mobile center
CrosshairGui.Parent = PlayerGui

-- IMAGE LABEL WITH YOUR ASSET
local CrosshairImage = Instance.new("ImageLabel")
CrosshairImage.Size = UDim2.new(0, 40, 0, 40) -- Good size to see clearly
CrosshairImage.BackgroundTransparency = 1
CrosshairImage.Image = "rbxassetid://5998624778" -- YOUR ASSET ID
CrosshairImage.Parent = CrosshairGui

-- LOCK TO TRUE CENTER EVERY FRAME
RunService.RenderStepped:Connect(function()
    local screenSize = workspace.CurrentCamera.ViewportSize
    CrosshairImage.Position = UDim2.new(
        0, screenSize.X/2 - CrosshairImage.AbsoluteSize.X/2,
        0, screenSize.Y/2 - CrosshairImage.AbsoluteSize.Y/2
    )
end)

-- ==============================================
-- ADDITIONAL FUNCTIONS (5X ZOOM)
-- =============================================
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local zoomEnabled = false
local normalFOV = 70  -- Default Roblox FOV; updates dynamically
local ZOOM_FOV = 12   -- 5x zoom

-- Update normal FOV every frame when not zoomed
RunService.RenderStepped:Connect(function()
    if not zoomEnabled then
        normalFOV = Camera.FieldOfView
    end
end)

-- Persistent zoom setter
local function applyZoom()
    if zoomEnabled then
        Camera.FieldOfView = ZOOM_FOV
    else
        Camera.FieldOfView = normalFOV
    end
end

-- Run applyZoom every frame to override any game resets
RunService.RenderStepped:Connect(applyZoom)

-- Toggle on U key
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.U then
        zoomEnabled = not zoomEnabled
        applyZoom()  -- Immediate apply
        print("Zoom:", zoomEnabled and "ON (5x)" or "OFF")
    end
end)
